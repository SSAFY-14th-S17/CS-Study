# Prepared Statement 완벽 가이드

Prepared Statement(준비된 명령문)는 데이터베이스 관리 시스템(DBMS)에서 SQL 쿼리를 실행할 때 사용되는 매우 중요하고 효율적인 방식입니다. 이 글에서는 Prepared Statement가 무엇인지, 내부적으로 어떻게 작동하는지, 왜 사용해야 하는지에 대해 초보자도 이해할 수 있도록 아주 상세하게 설명합니다.

-----

## 1\. Prepared Statement란 무엇인가?

Prepared Statement는 **미리 컴파일된 SQL 문**을 의미합니다.

이해를 돕기 위해 비유를 들어보겠습니다.

  * **일반 Statement:** 매번 관공서에 가서 서류 양식을 새로 손으로 작성하고, 공무원이 그 양식이 올바른지 처음부터 끝까지 검토하는 방식입니다. 이름만 달라도 양식 전체를 다시 검사받아야 합니다.
  * **Prepared Statement:** 미리 완벽하게 검증된 **빈칸이 뚫린 인쇄된 양식**을 관공서에 등록해 두는 것입니다. 민원인은 빈칸(이름, 주소)만 채워서 제출하면 됩니다. 공무원은 양식 자체를 다시 검토할 필요 없이 빈칸의 내용만 확인하고 바로 처리합니다.

기술적으로 말하면, SQL 문장의 틀(Template)을 미리 데이터베이스에 전송하여 분석 및 최적화를 끝내두고, 나중에 실제 데이터(Parameter)만 채워서 실행하는 방식입니다.

-----

## 2\. 구조와 작동 원리

Prepared Statement의 가장 큰 특징은 SQL 문장과 데이터(값)를 완전히 분리한다는 점입니다. 이를 위해 \*\*플레이스홀더(Placeholder)\*\*라는 개념을 사용합니다. 보통 물음표(`?`) 기호를 사용합니다.

### 시각적 구조 (ASCII Art)

일반적인 SQL 문은 데이터와 코드가 섞여 있지만, Prepared Statement는 아래와 같이 분리됩니다.

```text
[1단계: 쿼리 틀 준비 (PREPARE)]
데이터베이스에 이 틀을 먼저 보냅니다. 물음표(?)는 나중에 채울 빈칸입니다.

    SELECT * FROM users WHERE id = ? AND password = ?


[2단계: 데이터 바인딩 (BIND)]
실제 값을 따로 보냅니다.

    첫 번째 ? <-- "admin"
    두 번째 ? <-- "1234"


[3단계: 실행 (EXECUTE)]
데이터베이스가 틀에 값을 넣어 결과를 만듭니다.
```

### 상세 작동 프로세스 3단계

Prepared Statement가 실행될 때 데이터베이스 내부에서는 다음과 같은 일이 일어납니다.

#### Step 1. 준비 (Preparation)

애플리케이션이 쿼리 문장을 데이터베이스에 보냅니다. 이때 값은 넣지 않고 `?`로 비워둡니다.
데이터베이스는 이 문장을 받아서 다음 작업을 수행합니다:

1.  **문법 검사 (Parsing):** SQL 문법이 올바른지 확인합니다.
2.  **유효성 검사:** 테이블 이름이나 컬럼 이름이 실제로 존재하는지 확인합니다.
3.  **실행 계획 수립 (Optimization):** 이 쿼리를 가장 빠르게 실행할 수 있는 경로(알고리즘)를 계산합니다.
4.  **캐싱 (Caching):** 처리된 결과를 메모리에 저장해 둡니다.

#### Step 2. 바인딩 (Binding)

애플리케이션이 `?` 위치에 들어갈 실제 데이터를 보냅니다. 데이터베이스는 이 데이터를 SQL 문법이 아닌 단순한 **값**으로 인식하여 미리 준비된 틀에 연결합니다.

#### Step 3. 실행 (Execution)

완성된 쿼리를 실행하고 결과를 반환합니다. 만약 같은 쿼리 틀을 사용하고 값만 다른 요청이 또 들어오면, 데이터베이스는 Step 1을 생략하고 바로 Step 2부터 진행합니다.

-----

## 3\. 왜 사용하는가? (핵심 장점 2가지)

Prepared Statement를 사용하는 이유는 크게 \*\*성능(Performance)\*\*과 **보안(Security)** 두 가지입니다.

### 장점 1: 성능 향상 (재사용성)

일반 Statement 방식은 쿼리가 실행될 때마다 문법 검사, 해석, 최적화 과정을 반복해야 합니다. 아주 미세한 차이(예: 검색하는 ID가 1에서 2로 바뀜)가 있어도 데이터베이스는 이를 완전히 새로운 쿼리로 인식합니다.

반면, Prepared Statement는 **실행 계획을 재사용**합니다.

```text
[일반 Statement의 처리 과정]
요청 1: "SELECT.. WHERE id=1" -> [분석] -> [컴파일] -> [최적화] -> [실행]
요청 2: "SELECT.. WHERE id=2" -> [분석] -> [컴파일] -> [최적화] -> [실행]
(모든 단계 반복 = 느림)

[Prepared Statement의 처리 과정]
준비: "SELECT.. WHERE id=?"   -> [분석] -> [컴파일] -> [최적화] -> [저장]

요청 1: 값(1) 전달            -> [저장된 계획 불러오기] -> [바인딩] -> [실행]
요청 2: 값(2) 전달            -> [저장된 계획 불러오기] -> [바인딩] -> [실행]
(복잡한 앞단계 생략 = 빠름)
```

따라서 웹 서비스처럼 동일한 형태의 쿼리를 수천, 수만 번 반복해서 실행해야 하는 환경에서는 압도적인 성능 차이를 보입니다.

### 장점 2: 보안 강화 (SQL Injection 방지)

이것이 Prepared Statement를 사용해야 하는 가장 중요한 이유입니다. 해커가 입력창에 악의적인 SQL 코드를 집어넣어 데이터베이스를 조작하는 **SQL 인젝션(SQL Injection)** 공격을 원천적으로 차단합니다.

#### 공격 시나리오 (일반 Statement 사용 시)

로그인 쿼리가 다음과 같이 문자열을 이어 붙이는 방식이라고 가정해 봅시다.
`"SELECT * FROM users WHERE name = '" + input_name + "'"`

해커가 이름 입력창에 `' OR '1'='1` 이라고 입력하면, 완성된 쿼리는 다음과 같습니다.
`SELECT * FROM users WHERE name = '' OR '1'='1'`

`'1'='1'`은 항상 참(True)이므로, 해커는 비밀번호 없이도 로그인이 되어버립니다.

#### 방어 시나리오 (Prepared Statement 사용 시)

Prepared Statement는 쿼리의 구조(코드)와 데이터(값)를 엄격하게 구분합니다.

쿼리 틀: `SELECT * FROM users WHERE name = ?`

해커가 `?`에 `' OR '1'='1` 이라는 값을 넣어서 보냅니다.
데이터베이스는 이것을 실행 가능한 코드로 보지 않고, 단순히 **특이한 이름을 가진 문자열**로 취급합니다.

즉, 데이터베이스는 이름이 정확히 `"' OR '1'='1"`인 사람을 찾으려고 시도합니다. 당연히 그런 이름을 가진 사용자는 없으므로 로그인은 실패하고 공격은 무력화됩니다.

```text
[SQL Injection 방어 원리]

      (해커의 공격 시도)
      입력값:  ' OR '1'='1
             |
             v
+----------------------------+
|     Prepared Statement     |
|----------------------------|
|  코드 영역: SELECT ... ?   |  <-- 여기는 절대 수정 불가
|----------------------------|
|  데이터 영역: ' OR '1'='1  |  <-- 여기는 오직 '값'으로만 인식
+----------------------------+
             |
             v
    (데이터베이스의 해석)
"name 컬럼에 [ ' OR '1'='1 ] 이라는
글자가 들어있는 사람을 찾아라."

결과: 검색 실패 (안전함)
```

-----

## 4\. 사용 예시 (개념적 코드)

프로그래밍 언어마다 문법은 다르지만, 흐름은 동일합니다.

**나쁜 예 (일반 Statement)**

```text
String name = 사용자입력값;
String sql = "INSERT INTO users (username) VALUES ('" + name + "')";
// 입력값에 따옴표(')가 들어가면 쿼리가 깨지거나 해킹당함
statement.execute(sql);
```

**좋은 예 (Prepared Statement)**

```text
String sql = "INSERT INTO users (username) VALUES (?)";
// 1. 쿼리 틀 생성 (준비)
PreparedStatement pstmt = connection.prepareStatement(sql);

// 2. 데이터 바인딩 (물음표 채우기)
// 첫 번째 물음표에 사용자 입력값을 넣음
pstmt.setString(1, 사용자입력값);

// 3. 실행
pstmt.execute();
```

-----

## 5\. 요약

1.  **Prepared Statement**는 SQL 쿼리의 틀을 미리 컴파일해 두고 값만 나중에 채워 넣는 방식입니다.
2.  **작동 방식**은 `준비(Prepare)` -\> `바인딩(Bind)` -\> `실행(Execute)` 3단계로 나뉩니다.
3.  **성능:** 쿼리 분석 및 최적화 과정을 한 번만 수행하고 재사용하므로 반복 실행 시 속도가 빠릅니다.
4.  **보안:** 코드와 데이터를 분리하여 처리하므로 **SQL Injection 공격을 완벽하게 방어**할 수 있습니다.