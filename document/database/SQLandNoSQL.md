# SQL vs NoSQL

데이터베이스 기술은 단순히 "데이터를 저장하는 공간"을 넘어, 애플리케이션의 성능, 확장성, 그리고 일관성을 결정짓는 핵심 아키텍처입니다. 이 글에서는 RDBMS(SQL)와 NoSQL의 내부 메커니즘과 선택 기준을 바닥부터 훑어봅니다.

-----

## 1\. SQL (RDBMS): 엄격함과 정합성의 미학

\*\*관계형 데이터베이스 관리 시스템(RDBMS)\*\*은 1970년 E.F. Codd 박사의 논문에서 시작되었습니다. 수학적 집합론에 기반을 두며, \*\*데이터의 중복을 0으로 만드는 것(정규화)\*\*을 목표로 합니다.

### 1.1 핵심 철학: ACID 트랜잭션

RDBMS가 금융권이나 결제 시스템에서 절대적인 지위를 차지하는 이유는 **ACID** 속성 때문입니다.

1.  **Atomicity (원자성):** 트랜잭션 내의 작업은 모두 성공하거나, 하나라도 실패하면 모두 취소(Rollback)되어야 합니다. (All or Nothing)
2.  **Consistency (일관성):** 트랜잭션이 완료되면 데이터는 미리 정의된 규칙(제약 조건)을 만족해야 합니다.
3.  **Isolation (격리성):** 동시에 여러 트랜잭션이 수행될 때, 서로의 작업에 영향을 주어서는 안 됩니다.
4.  **Durability (지속성):** 한 번 커밋된 데이터는 시스템이 꺼져도 영원히 보존되어야 합니다.

### 1.2 데이터 모델: 정규화 (Normalization)와 JOIN

SQL은 데이터를 중복 저장하지 않기 위해 테이블을 쪼갭니다(정규화). 그리고 쪼개진 데이터를 다시 합쳐서 보여주기 위해 **JOIN** 연산을 사용합니다.

**[SQL의 JOIN 메커니즘]**
사용자 테이블과 주문 테이블이 분리되어 있으며, `User_ID`를 통해 논리적으로 결합됩니다.

```text
+----------------+           +----------------+
|  [Table: User] |           | [Table: Order] |
|----------------|           |----------------|
| PK: User_ID    |<----JOIN--| FK: User_ID    |
|     Name       |           |     Order_ID   |
|     Email      |           |     Product    |
|     Address    |           |     Price      |
+----------------+           +----------------+
        ^
        | (데이터 수정 시 이곳만 수정하면 됨 = 데이터 무결성)
```

### 1.3 한계점: The Scaling Wall

RDBMS는 단일 서버에서의 강력한 성능을 보장하지만, 데이터가 폭증하여 서버 한 대로 감당이 안 될 때 문제가 발생합니다.

  * **Sharding(샤딩)의 복잡성:** 데이터를 여러 서버에 쪼개 넣으려면 애플리케이션 레벨에서 복잡한 로직이 필요합니다.
  * **JOIN의 비효율:** 분산된 서버 간에 JOIN을 수행하는 것은 성능상 매우 큰 비용이 듭니다.

#### 1.3.1 샤딩(Sharding)이란?

샤딩은 하나의 거대한 테이블을 **수평으로 나누어 여러 데이터베이스 인스턴스(샤드)**에 분산 저장하는 기법입니다. 보통 `User_ID % N`과 같은 키 기반 라우팅이나 일관 해싱을 사용해 어느 샤드에 요청을 던질지 결정합니다.

- **장점:** 샤드를 늘리면 처리량이 선형에 가깝게 증가하므로, 핫한 테이블이라도 특정 샤드만 스케일아웃하면 됩니다.
- **단점:** 샤드 간 트랜잭션·JOIN을 처리하기 어렵고, 균형이 깨지면(Hot Spot) 특정 샤드만 과부하될 수 있습니다.
- **SQL vs NoSQL:** RDBMS도 샤딩이 가능하지만 애플리케이션이 샤드 라우팅과 트랜잭션 분산을 직접 처리해야 합니다. 대부분의 NoSQL은 애초에 분산·샤딩 아키텍처를 전제로 만들어져 있어, 노드를 추가하기만 해도 자동으로 샤드를 재분배하거나 가상 샤드(리밸런서)가 이를 처리합니다.

-----

## 2\. NoSQL: 유연성과 확장성의 혁명

2000년대 후반, 구글, 아마존, 페이스북 등은 기존 RDBMS로는 감당할 수 없는 페타바이트급 데이터를 처리해야 했습니다. 그래서 탄생한 것이 NoSQL입니다. 이는 **"Not Only SQL"** 혹은 \*\*"No SQL"\*\*을 의미하며, RDBMS의 규칙을 깹니다.

### 2.1 이론적 배경: CAP 정리 (Brewer's Theorem)

분산 시스템에서는 다음 세 가지 중 **오직 두 가지만 선택**할 수 있다는 이론입니다.

  * **Consistency (일관성):** 모든 노드가 동시에 같은 데이터를 보여주는가?
  * **Availability (가용성):** 일부 노드가 고장 나도 응답을 받을 수 있는가?
  * **Partition Tolerance (분할 내성):** 네트워크 단절(메시지 손실)이 일어나도 시스템이 동작하는가?

RDBMS는 주로 **CA**를 만족하지만 분산 환경에 약합니다. 반면, NoSQL은 **CP**나 **AP** 시스템을 지향합니다.

**[CAP 이론 다이어그램]**

```text
       Consistency (일관성)
          /   \
         /     \
    CA  /       \  CP (MongoDB, HBase)
(RDBMS)/_________\
      /    CAP    \
     /   Theorem   \
Availability ----- Partition Tolerance
  (가용성)            (분할 내성)
      AP (Cassandra, DynamoDB)
```

[Image of CAP Theorem Venn Diagram]

### 2.2 운영 철학: BASE

ACID와 대척점에 있는 개념으로, 완벽한 일관성보다는 가용성을 중시합니다.

  * **Basically Available:** 언제든지 다수의 사용자가 접근 가능해야 한다.
  * **Soft state:** 노드의 상태는 외부 정보 없이도 변경될 수 있다.
  * **Eventual consistency (결과적 일관성):** 당장은 데이터가 안 맞을 수 있지만, 시간이 지나면 결국 같아진다. (예: 유튜브 조회수가 서버마다 다르게 보이다가 나중에 맞춰지는 현상)

-----

## 3\. NoSQL의 4가지 주요 유형 (심화)

NoSQL은 하나의 기술이 아닙니다. 저장 방식에 따라 크게 네 가지로 나뉩니다.

### 3.1 Key-Value Store (키-값 저장소)

가장 단순하고 빠릅니다. 해시 테이블 구조를 가집니다.

  * **특징:** 값을 해석하지 않고 바이너리 덩어리(Blob)로 저장합니다.
  * **용도:** 세션 관리, 장바구니, 캐싱 (Redis, Memcached).
  * **구조:**
    ```text
    Key       |  Value
    ----------+-----------------------
    "user:1"  |  "Alice, Seoul, 25"
    "sess:99" |  "Active, Expires:3600"
    ```

### 3.2 Document Store (문서 저장소)

데이터를 JSON, XML 같은 문서 형태로 저장합니다. 계층적인 데이터 구조를 그대로 저장할 수 있습니다.

  * **특징:** 스키마가 유연하여 문서마다 다른 필드를 가질 수 있습니다. 개발자 친화적입니다.
  * **용도:** 콘텐츠 관리 시스템(CMS), 카탈로그, 로그 저장 (MongoDB).
  * **구조:**
    ```text
    [Document: User Profile]
    {
      "_id": "user123",
      "name": "James",
      "contacts": {          <-- 계층 구조 지원
         "email": "j@test.com",
         "phone": "010-xxxx"
      },
      "history": ["login", "purchase"] <-- 배열 저장 가능
    }
    ```

### 3.3 Column-Family Store (컬럼 패밀리 저장소)

하나의 키에 여러 개의 컬럼이 매핑되지만, RDBMS와 달리 모든 행이 같은 컬럼을 가질 필요가 없습니다. "Wide Column Store"라고도 합니다.

  * **특징:** 쓰기 성능이 매우 뛰어나고, 대량의 데이터 집계에 유리합니다.
  * **용도:** 시계열 데이터, IoT 센서 데이터, 페이스북 메시지함 (Cassandra, HBase).
  * **구조:**
    ```text
    Row Key  |  Column Family: Personal  |  Column Family: Logs
    ---------+---------------------------+---------------------
    ID_100   |  name: "Kim", age: 30     |  login: 12:00
    ID_101   |  name: "Lee"              |  login: 12:05, error: null
    ```

### 3.4 Graph Database (그래프 데이터베이스)

데이터(Node)와 관계(Edge)를 그래프 구조로 저장합니다. "관계" 자체가 데이터로 저장되므로 JOIN 없이 연결된 데이터를 찾을 수 있습니다.

  * **특징:** 복잡한 관계 탐색 속도가 O(1)에 가깝습니다.
  * **용도:** 소셜 네트워크 추천 친구, 사기 탐지, 지식 그래프 (Neo4j).

**[그래프 데이터베이스 구조]**
데이터 간의 관계가 물리적으로 연결되어 있음.

```text
    (Person: Alice) --- [FRIEND] ---> (Person: Bob)
          |                                 |
       [LIKES]                           [BOUGHT]
          |                                 |
          v                                 v
    (Product: iPhone) <--- [BRAND] --- (Company: Apple)
```

-----

## 4\. SQL vs NoSQL: 아키텍처 관점의 비교

개발자가 시스템을 설계할 때 고려해야 할 실질적인 차이점입니다.

| 비교 항목 | SQL (RDBMS) | NoSQL (Document/Key-Value) |
| :--- | :--- | :--- |
| **확장 방식** | **Scale-Up** (고성능 장비로 교체) | **Scale-Out** (저렴한 서버 추가) |
| **스키마** | **Schema-on-Write** (쓸 때 검사) | **Schema-on-Read** (읽을 때 해석) |
| **쿼리 언어** | 표준 SQL 제공 (강력한 집계 가능) | DB마다 다름 (기능 제한적일 수 있음) |
| **트랜잭션** | 전체 시스템 수준의 ACID 보장 | 단일 문서/레코드 수준의 원자성만 보장 (대부분) |
| **데이터 수정** | 한 곳만 수정하면 전체 반영 (정규화됨) | 여러 문서를 수정해야 할 수도 있음 (중복 저장됨) |

-----

## 5\. 현대적인 접근: Polyglot Persistence (폴리글랏 퍼시스턴스)

최근의 아키텍처 트렌드는 \*\*"둘 중 하나만 고르는 것이 아니라, 적재적소에 섞어 쓰는 것"\*\*입니다. 이를 **폴리글랏 퍼시스턴스**라고 합니다.

### 실제 서비스 아키텍처 예시 (전자상거래 앱)

하나의 앱 안에서 데이터의 성격에 따라 다른 DB를 사용합니다.

1.  **회원 정보, 결제 내역, 재고 관리:**
      * 👉 **RDBMS (MySQL/PostgreSQL)** 사용
      * 이유: 데이터 무결성과 트랜잭션이 생명이므로.
2.  **상품 카탈로그, 상세 설명:**
      * 👉 **NoSQL (MongoDB)** 사용
      * 이유: 상품마다 속성이 다르고(옷은 사이즈, 노트북은 CPU), 읽기 요청이 많으므로.
3.  **장바구니, 사용자 세션:**
      * 👉 **Key-Value (Redis)** 사용
      * 이유: 매우 빠른 입출력이 필요하고, 영구 저장이 필수적이지 않으므로.
4.  **친구 추천, "이 상품을 본 사람이 산 상품":**
      * 👉 **Graph DB (Neo4j)** 사용
      * 이유: 사용자 간의 관계를 파악해야 하므로.

-----

## 6\. 결론 및 요약

**무조건 더 좋은 데이터베이스는 없습니다.**

  * **SQL**은 데이터가 중요하고, 변화가 적으며, 일관성이 필수적인 시스템의 **심장**과 같습니다.
  * **NoSQL**은 빠르게 변화하고, 양이 방대하며, 확장성이 중요한 시스템의 **손발**과 같습니다.