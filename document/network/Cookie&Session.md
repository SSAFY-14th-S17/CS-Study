# HTTP 프로토콜의 특징

## 비연결형 지향

클라이언트가 요청을 했을 때 그 요청에 맞는 응답을 보낸 후 연결을 끊는 처리 방식이다. 서버 자원을 효율적으로 관리할 수 있게 해주며, 수많은 클라이언트 요청을 처리하는 데에 유리하다. `keep-alive`와 같은 옵션이 아니라면, HTTP는 기본적으로 비연결형을 지향하고 있다.

<br>

## Statless 프로토콜

커넥션을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보를 유지하지 않는 특징이 있다. 즉, 각각의 요청은 독립적이며  서버는 이전 요청에 대한 정보를 기억하지 않는다. 
<br>

따라서 정보가 유지되지 않는데, 웹 상에서는 로그인과 같이 동일한 상태 유지가 필요한 경우가 존재한다.

그래서 추가로 사용하는 것이 **쿠키**와 **세션**이다.

이 때 쿠키는 클라이언트(브라우저)에 저장하고, 세션(서버)에 저장한다.

<br>

# Cookie

## 정의

브라우저에 보관되는 작은 데이터(단순 클라이언트 저장 데이터) 조각이다. 서버가  HTTP 응답 헤더의 `Set-Cookie`를 통하여 클라이언트에게 전달한다면, 클라이언트는 이를 저장하고 이후 동일한 서버에 요청할 때마다 `Cookie` 헤더에 담아 자동으로 전송한다.

```
// 서버 -> 클라이언트 (HTTP Response)
Set-Cookie: sessionId=abc123; Path=/; HttpOnly

// 클라이언트 -> 서버 (HTTP Request)
Cookie: sessionId=abc123
```

## 종류

- 세션 쿠키(Session Cookie) : 만료날짜를 지정하지 않은 쿠키이다. 브라우저를 닫으면 자동으로 삭제되는 것으로, **메모리**에만 저장되며 디스크에 기록되지 않는다.

- 영구 쿠기(Persistent Cookie) : `Expires` 또는 `Max-Age` 속성으로 만료 날짜를 지정한 쿠키이다. 지정된 기간 동안 디스크에 저장되어 브라우저를 닫아도 유지된다. 자동 로그인, 사용자 설정 저장 등에 활용된다.

## 특징

- 이름, 값, 만료일(저장기간), 경로 정보, 보안속성(Secure, HttpOnly, SameSite 등)
- 클라이언트에 총 300개의 쿠키를 저장 가능
- 하나의 도메인 당 20개의 쿠키를 저장 가능
- 하나의 쿠키는 4KB까지 저장 가능

### 보안 속성

- `Secure` : HTTPS 연결에서만 쿠키 전송을 허용
- `HttpOnly` : JavaScript에서 쿠키에 접근할 수 없도록 설정(XSS 공격 방어)
- `SameSite` : 크로스 사이트 요청 시 쿠키 전송 여부를 제어(CSRF 공격 방어)

##  동작 순서

![img](/document/images/cookie_session_1.png)

1. 클라이언트가 페이지를 요청한다.
2. 웹 서버는 쿠키를 생성한다.
3. 생성한 쿠키에 정보를 담아 HTTP 응답의 Set-Cookie 헤더에 포함하여 클라이언트에게 전달한다.
4. 브라우저는 전달받은 쿠키를 저장한다.
5. 이후 동일 도메인에 요청할 때, 브라우저는 저장된 쿠키를 Cookie 헤더에 담아 자동으로 전송한다.

## 한계

### 보안 취약점

HTTPS가 아닌 환경에서는 공격자가 네트워크를 통해 쿠키를 탈취하는 것이 가능하다.
XSS(Cross-Site Scripting) 공격을 통해 JavaScript로 쿠키에 접근할 수 있다. (HttpOnly 속성으로 방어 가능)
CSRF(Cross-Site Request Forgery) 공격에 취약하다. (SameSite 속성으로 방어 가능)

### 기능적 한계

저장 용량이 4KB로 제한되어 대용량 데이터 저장에 부적합하다.
매 요청마다 쿠키가 전송되므로 불필요한 트래픽이 발생할 수 있다.
사용자가 브라우저 설정에서 쿠키를 비활성화하거나 삭제할 수 있다.

<br>

참고로, HTTP 브라우저 상에서의 쿠키와 서버 측 언어의 쿠키 객체는 다르다.
(예: Java에도 Cookie라는 객체가 존재한다. 하지만 JSP가 아니라 별도의 프론트엔드 페이지를 제작하는 경우라면, 이 쿠키는 브라우저 쿠키와 별개의 것임을 알아두자.)

<br>

# Session

## 정의

일정 시간동안 같은 사용자(브라우저)로부터 들어오는 일련의 요청을 하나의 상태로 보고, 그 상태를 유지시키는 **서버 측** 기술이다. 방문자가 웹 서버에 접속해있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.

쿠키가 단순히 클라이언트에 저장되는 데이터라면, 세션은 서버 상에서 관리되는 것이다. 서버는 고유한 클라이언트 식별을 위해 세션ID를 발급하고, 이 세션 ID를 쿠키에 담아 클라이언트에게 전달한다. 클라이언트는 요청마다 세션ID를 함께 보내고, 서버는 이를 통해 클라이언트를 식별하고 해당 세션에 저장된 데이터에 접근한다.

## 동작순서
1. 클라이언트가 서버에 최초로 요청을 보낸다.
2. 서버는 클라이언트에 대한 세션을 생성하고, 고유한 세션ID를 발급한다.
3. 서버는 세션ID를 `Set-Cookie` 헤더에 담아 응답한다. (`JSESSIONID`) 이 세션ID는 쿠키에 담고, 이를 구분하는 사용자의 정보들은 서버에 저장
4. 브라우저는 세션ID가 담긴 쿠키를 저장한다.
5. 이후 요청 시, 브라우저는 세션ID 쿠키를 함께 전송한다.
6. 서버는 세션ID를 통해 해당 클라이언트의 세션 데이터를 조회하여 상태를 유지한다.

## 특징

- 웹 컨테이너의 상태를 유지하기 위한 정보 저장
- 웹 "서버"에 저장되는 쿠키로, **세션ID만 클라이언트(쿠키)에 저장되고, 실제 데이터는 서버에 저장**
- 브라우저를 닫거나, 세션 타임아웃이 지나거나, 서버에서 세션을 삭제했을 때에만 삭제됨
- 쿠키보다 보안성이 높음(민감한 정보가 서버에 저장되기 때문)


## 한계

- **세션 하이재킹** : 공격자가 XSS, 네트워크 스니핑, 중간자 공격 등을 통해서 JSESSIONID를 탈취하면, 해당 세션에 대한 모든 권한을 가로채는 것이 가능
(대응 방법 : HTTPS 사용, `HttpOnly` / `Secure` 쿠키 설정, 세션ID 주기적 갱신 등)

- **세션 고정** : 공격자가 임의로 세션 ID를 지정해 사용자가 그것을 사용하도록 유도하면, 인증 완료 후에도 공격자가 동일한 세션을 재사용하는 것이 가능
(대응 방법 : 인증 성공 후 세션ID 재발급)

- **서버 부하**: 서버는 모든 유효 세션을 메모리에 저장하며, 공격자가 무효 세션 ID를 반복적으로 보내면, 서버가 매번 새로운 세션을 생성해 메모라와 CPU를 소진시키는 DoS 형태의 부하를 유발하는 것이 가능


## 세션의 저장소

- 메모리: 가장 빠르지만 서버 재시작 시에는 세션이 소멸된다. 단일 서버 환경에서만 적합하다.
- 파일 시스템: 서버 재시작 후에도 세션이 유지되지만, 다중 서버 환경에서 공유가 어렵다.
- 데이터베이스: 영구 저장이 가능하고, 다중서버에서도 공유가 가능하지만, 상대적으로 속도가 느리다.
- Redis/Memcached: 인메모리 기반으로 빠르면서도 다중 서버 환경에서 세션 공유가 가능하다. 최근 가장 많이 사용된다.