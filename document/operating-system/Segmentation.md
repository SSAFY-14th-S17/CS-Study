# Sementation(세그먼테이션)

프로세스를 **논리적** 인 의미 단위로 나누어 물리적 메모리에 배치하는 방식이다.

페이징(paging) 기법이 고정된 크기의 페이지 단위를 사용했던 것과 달리, 세그먼테이션은 고정에 집착하지 않고 **가변 크기의 논리적 블록** 을 단위로 메모리를 관리한다.

프로그램을 코드(Code), 데이터(Data), 스택(Stack) 등 **논리적으로 구분 가능한 의미 단위(Segment)** 로 나누기 때문에 각 세그먼트는 크기가 다르며, 독립적으로 물리 메모리에 배치된다.

![](/document/images/segment1.png)

* **예시:**

  * Code Segment : 실행 코드 저장
  * Data Segment : 전역 변수 및 데이터 저장
  * Stack Segment : 함수 호출 시 지역 변수 및 복귀 주소 저장

<br>
<br>


## 구성 요소

![](/document/images/segment2.png)

| 구성 요소                       | 설명                          |
| --------------------------- | --------------------------- |
| **세그먼트(Segment)**           | 프로세스를 구성하는 논리적 의미 단위        |
| **세그먼트 테이블(Segment Table)** | 각 세그먼트의 물리적 위치 정보를 저장하는 테이블 |
| **Base (기준 주소)**            | 세그먼트가 물리 메모리에서 시작되는 주소      |
| **Limit (세그먼트 크기)**         | 세그먼트의 길이(바이트 단위)            |


<br>
<br>

## 주소 변환 방식

1. CPU는 논리 주소를 **(세그먼트 번호, 오프셋)** 형태로 생성
2. 세그먼트 테이블에서 해당 세그먼트 번호를 조회하여 **Base**와 **Limit**을 가져옴
3. 논리 주소의 오프셋이 Limit을 초과하지 않으면,
   `물리 주소 = Base + Offset` 으로 변환
4. Limit을 초과할 경우, **세그먼트 오류(Segment Fault)** 가 발생

<br>
<br>


## 장점

* **내부 단편화 최소화:**
  세그먼트 크기가 실제 필요 크기만큼 할당되므로 **내부 단편화가 발생하지 않는다.** (페이징과의 차이점)
* **보호 및 공유 용이:**
  각 세그먼트별로 접근 권한(Read, Write, Execute 등)을 설정할 수 있으며,
  코드 세그먼트 등은 여러 프로세스 간 공유가 가능하다.
* **논리적 구조 반영:**
  프로그램의 논리적 구조(코드, 데이터, 스택 등)가 메모리 구조에 직접 반영된다.



## 단점

* **외부 단편화(External Fragmentation):**
  세그먼트의 크기가 가변적이기 때문에, 메모리의 할당과 해제가 반복되면
  사용되지 못하는 작은 빈 공간들이 흩어져 발생하여 메모리 낭비가 일어난다. ( 페이징과의 큰 차이점 )
* **복잡한 관리:**
  세그먼트 테이블 관리 및 주소 변환 과정이 페이징보다 복잡하다.
* **연속 공간 요구:**
  각 세그먼트가 연속된 물리 메모리 공간을 필요로 하므로 대규모 세그먼트를 배치하기 어렵다.
