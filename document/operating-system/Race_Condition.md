# Race-Condition

: 여러 프로세스 / 스레드가 동시에 공유자원에 접근할 때 접근 순서에 따라 결과가 달라질 수 있는 상태

- 컴퓨터는 여러 스레드를 매우 빠른 속도로 번갈아가며 실행 (Context Switching)
- 여러 스레드가 하나의 자원을 차지하기 위해 경쟁하는 과정에서 문제 발생
  여러 스레드의 예측 불가능한 실행 순서로 자원의 일관성이 깨져 프로그램 결과가 불안정해지고, 디버깅이 어려움

<br>

**[e.g.] 여러 스레드의 공유 변수의 접근**
| **순서** | **스레드 A (CPU 1)** | **스레드 B (CPU 2)** | **메모리 count** |
|:--------:|:------------------------------|:------------------------------|:----------------:|
| 1 | `count`를 읽음 (값: 10) | | 10 |
| 2 | | `count`를 읽음 (값: 10) | 10 |
| 3 | 값을 1 증가 (레지스터: 11) | | 10 |
| 4 | | 값을 1 증가 (레지스터: 11) | 10 |
| 5 | 레지스터 값을 `count`에 씀 | | **11** |
| 6 | | 레지스터 값을 `count`에 씀 | **11** |

- 예측: 스레드 2개가 `count++`를 각각 한 번씩 실행하면 `count`가 2 증가해야 함
- 컴퓨터의 실제 동작: `count++` 은 한 번에 실행되지 않고, 3단계로 쪼개져 실행됨 →원자적(atomic) 연산 X

- **[읽기]** 메모리에서 `count`의 현재 값을 CPU 레지스터로 가져옴

- **[증가]** CPU 레지스터의 값을 1 증가시킴

- **[쓰기]** 증가된 값을 다시 메모리의 `count`에 덮어씀

→ Race Condition을 해결하는 것 : 동기화!
