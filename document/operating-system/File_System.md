# 1. 파일 시스템 개념

파일 시스템은 물리적인 저장 장치를 OS가 관리할 수 있도록 논리적인 파일 & 폴도로 체계화하는 규칙임
(파일 → 책, 폴더 → 책장)

OS는 이 규칙을 통해 데이터를 추상화하고, 저장 공간을 효율적으로 관리하며, 파일을 빠르게 검색하고 안전하게 보호할 수 있음

## 1-1. 파일 시스템이란?

| 종류  | 특징                         | 사용 예          |
| ----- | ---------------------------- | ---------------- |
| FAT32 | 단순, 오래된 시스템          | USB, 메모리 카드 |
| NTFS  | 권한, 암호화, 저널링 지원    | Windows          |
| ext4  | 저널링, 안정적               | Linux            |
| APFS  | SSD 최적화, 스냅샷           | macOS            |
| exFAT | FAT32 확장, 대용량 파일 지원 | 외장 HDD, USB    |

저장 장치(HDD, SSD 등)에 데이터를 저장하고 관리하는 방법과 구조
물리적인 공간을 논리적인 파일과 디렉토리 형태로 추상화해주는 체계

### 핵심 특징

1. 커널 영역 동작
   파일 시스템의 핵심 기능(메모리 할당, 디스크 I/O 등)은 안정성이 중요한 **커널 모드**에서 실행됨
2. 계층적 구조
   파일을 관리하기 쉬운 트리 구조로 구성하여 파일 탐색 및 분류를 용이하게 함
3. 무결성 메커니즘
   시스템 충돌이나 전원 문제 발생 시에도 데이터의 손상(파일 무결성)을 최소화하고 복구할 수 있는 메커니즘을 제공 (e.g. 저널링)

### 파일 시스템의 역할

- 파일 저장 / 검색
  파일을 디스크 블록 단위로 나누어 저장
  이름 - inode - 데이터 블록 구조로 효율적 탐색
- 파일 속성 관리
  크기, 생성 / 수정 시간
  접근 권한, 소유자, 타입 등
- 디렉토리 구조 제공
  트리 구조로 파일 / 폴더 관리
  경로를 통해 쉽게 파일에 접근 가능
- 공간 관리
  사용 중 / 빈 블록 추적
  단편화를 최소화함
- 안정성 확보
  저널링, 스냅샷으로 데이터 손실 최소화
  시스템 다운 후 복구 가능

⇒ HW 장치 만으로 파일 관리가 어려움
파일 시스템을 통하여 파일 관리의 접근성, 효율성, 안정성 보장

### 파일 시스템의 주요 구성 요소

1. **슈퍼 블록**

- 파일 시스템 전체 정보를 담고 있음
- 크기, 블록 개수, 사용 가능 공간, 파일 시스템 타입 등

1. **블록**

- 디스크에서 데이터를 저장하는 최소 단위 (보통 4KB ~ 64KB)
- 파일은 하나 이상의 블록으로 나뉘어 저장됨

1. **Inode (Index Node)**

- 각 파일에 대한 메타 데이터 저장
  파일의 종류, 파일 크기, 접근 권한, 실제 데이터가 저장된 블록 위치 (포인터)

1. **디렉토리**

- 파일 이름과 inode를 매핑하는 테이블
- 디렉토리를 통해 파일 경로를 탐색할 수 있음

### 파일 시스템의 주요 동작 (CRUD)

1.  **물리적 장치 추상화**
    OS는 디스크를 블록 단위로 나눔
    HDD: 섹터(Sector) 단위
    SSD: 페이지 단위
    FS는 이 블록을 논리적 단위로 매핑해서 파일을 저장
2.  **파일 생성**
    디렉토리에 파일 이름 등록
    inode 생성
    필요한 블록 할당
3.  **파일 읽기**
    디렉토리에서 파일 이름 → inode 찾기
    inode에서 데이터 블록 위치 확인
    블록을 읽어 메모리로 전달
4.  **파일 쓰기**
    데이터 블록 할당
    inode 업데이트 (파일 크기, 마지막 수정 시간,..)
5.  **파일 삭제**
    inode 해제
    데이터 블록 해제
    디렉토리 엔트리 제거

### [c.f] 저널링

> 무슨 작업을 할 건지 먼저 기록 → 실제 반영 → 완료 후 기록 삭제

: **파일 시스템에서 데이터나 메타데이터를 실제 디스크에 쓰기 전에 로그(Journal)에 기록하는 기법**

로그를 기반으로 시스템 다운이나 전원 장애 후에도 **파일 시스템 복구 및 일관성 유지** 가능

## 1-2. 파일과 디렉토리

### (1) 파일 (File)

- 사용자가 인식하는 정보의 논리적인 저장 단위
- 파일은 이름, 속성(유형, 크기, 생성 시간, 접근 권한 등), 데이터를 가짐
- OS는 이러한 속성은 파일 제어 블록 (FCB, File Control Block)에 저장하여 관리함

### 파일의 구성 요소

- **메타 데이터 영역 (Metadata Area):**
  - 파일 자체의 데이터가 아닌, 파일을 설명하는 정보(속성)를 저장
  - 포함 내용: **파일 이름, 파일의 데이터가 저장된 위치 주소, 크기, 소유자, 접근 권한, 생성/수정/접근 시간, 삭제 여부** 등
  - 이 메타 정보를 저장하는 대표적인 구조가 **FCB (File Control Block)** 또는 node (아이노드)임
  - FCB & Inode
    FCB: 파일이 열려있는 동안 OS 메모리에 존재
    Inode: 파일이 디스크에 존재하는 한 계속 존재
    | 항목 | FCB | inode |
    | --- | --- | --- |
    | 위치 | 메모리 내 자료 구조 | 디스크의 메타데이터 블록 |
    | 역할 | OS가 파일 관리 | 파일의 메타데이터 저장 |
    | 특징 | 일시적, 열려 있는 파일만 존재 | 영속적, 파일이 존재하는 동안 항상 존재 |
- **데이터 영역 (Data Area):**
  - 실제 파일의 내용(바이너리 코드, 텍스트, 이미지 등)이 저장되는 영역

### (2) 디렉토리 (Directory)

- 파일을 계층적으로 묶어 구조화하고 관리하는 도구
- 파일 이름과 해당 파일을 찾기 위한 정보를 매핑하여 저장함

### 디렉토리 구조

**1. 단일 레벨 디렉토리 (Single-Level Directory)**

- 시스템 내 파일이 하나의 디렉토리에만 존재함
- [+] 구현이 가장 단순함
- [-] 파일 이름 충돌 발생 쉬움, 파일 관리 어려움

<br>

**2. 2단계 디렉토리 (Two-Level Directory)**

        ```jsx
        Root Directory
        ├─ User A
        │    ├─ file1
        │    └─ file2
        └─ User B
                ├─ file1
                └─ file2
        ```

- 사용자별 루트 디렉토리 + 파일 디렉토리로 구성됨
- 사용자 독립성
  각 사용자는 자신만의 디렉토리 공간을 가짐
  사용자 A, B가 같은 이름의 파일을 만들어도 충돌 없음
  각 사용자는 자기 디렉토리 내에서만 파일 이름이 유일하면 됨
- 루트 디렉토리 → 사영자 디렉토리 → 파일 구조
- [+] 사용자별 파일 구분이 명확함
- [-] 디렉토리 깊이가 2단계로 고정 → 구조 유연성 낮음, 복잡한 폴더 구조 지원 불가

<br>

**3. 계층적/트리 구조 (Tree Structure)**

        ```jsx
        Root
        ├─ home
        │    ├─ userA
        │    │    ├─ docs
        │    │    │    └─ lecture.pdf
        │    │    └─ pics
        │    │         └─ img1.png
        │    └─ userB
        └─ var
        └─ log
                └─ syslog

        ```

- 파일과 디렉토리를 트리 형태로 구성하는 구조
- 루트 디렉토리를 최상위 노드로 하고, 하위 디렉토리와 파일들이 노드와 가지 형태로 연결됨
- 다단계 구조 가능 → 복잡한 파일 구조, 대규모 시스템에도 적합
- 경로로 파일 식별 (절대 경로, 상대 경로)
- [+] 파일의 논리적 그룹화 용이
- [-] 탐색 비용, 구조 관리의 복잡성

<br>

**4. 그래프 구조 (Acyclic-Graph)**

        ```jsx
                Root
                ├─ home
                │    ├─ userA
                │    │    └─ docs
                │    │         └─ lecture.pdf
                │    └─ userB
                │         └─ shared_docs -> lecture.pdf
                └─ var
                └─ log
        ```

- 트리 구조를 기반으로 하면서, 하위 디렉토리가 여러 부모 디렉토리를 가질 수 있는 구조
  트리 + 다중 참조 구조
- 동일 파일이나 디렉토리를 여러 위치에서 접근 가능 (링크)
  e.g. `shared_docs`는 userA/docs/lecture.pdf를 가리키는 **하드 링크(hard link)**
- 사이클은 허용하지 않음
- [+] 파일, 디렉토리 공유가 가능하여 효율성 높음
- [-] 순환 처리 복잡함

<br>

# 2. 디스크 공간 관리

파일 시스템은 파일의 논리적인 블록을 디스크의 물리적인 블록에 어떻게 대응시켜 저장할지를 결정함

디스크 공간 관리 목적

1. 파일 저장 시 빈 공간을 효율적으로 활용
2. 파일 삭제 시 공간 반환
3. 단편화 최소화
4. 파일 접근 속도 최적화

## 2-1. 공간 관리 기법

파일 데이터를 디스크 블록에 어떻게 배치할 것인가?

| 기법      | 특징                    | 장점                        | 단점                                       |
| --------- | ----------------------- | --------------------------- | ------------------------------------------ |
| 연속 할당 | 파일을 연속 블록에 저장 | 속도 빠름, 구현 단순        | 외부 단편화, 크기 변경 어려움              |
| 연결 할당 | 블록 포인터로 연결      | 단편화 없음, 크기 증가 용이 | 랜덤 접근 느림, 포인터 오버헤드            |
| 색인 할당 | 인덱스 블록 사용        | 랜덤 접근 가능, 단편화 완화 | 인덱스 블록 공간 필요, 큰 파일 다단계 필요 |

### (1) 연속 할당(Contiguous Allocation)

```jsx
디스크: [■■■■■■■■■■]  → 파일1 저장
```

파일의 모든 데이터 블록을 디스크의 연속된 물리적 블록에 저장함

- 장점
  순차 접근 및 직접 접근이 매우 빠르고, 구현이 단순함
- 단점
  외부 단편화 발생(External Fragmentation)
  파일 크기 변경 시 어려움 → 재배치 필요

### (2) 연결 할당(Linked Allocation)

```jsx
파일: 블록1 → 블록2 → 블록3 → ...
```

파일의 각 데이터 블록은 디스크에 흩어져 저장됨
각 블록은 다음 블록의 주소의 포인터 형태로 저장하여 연결함

- 장점
  외부 단편화 문제 완화
  파일 크기 증가 시 블록 추가 용이
- 단점
  순차 접근만 효율적, 임의 접근(Random Access) 느림
  포인터 저장 공간 낭비, 포인터 손상 시 데이터 접근이 끊어지는 신뢰성 문제

### (3) 인덱스 할당(Indexed Allocation)

```jsx
Index Block
 ├─ Block 5
 ├─ Block 7
 └─ Block 12

```

각 파일의 모든 디스크 블록 주소를 모아놓은 인덱스 블록을 사용함
인덱스 블록에 파일이 차지한 모든 블록 번호를 저장

- 장점
  임의 접근 가능
  외부 단편화 문제 완화
- 단점
  인덱스 블록을 위한 추가적인 공간 필요
  대용량 파일의 경우 인덱스 블록을 관리하는 것이 복잡해짐

## 2-2. 빈 공간 관리

디스크에서 사용 가능한 공간을 어떻게 추적하는가?

디스크 관리용 자료 구조로 크게 비트맵 / 자유 리스트 방식이 있음

### (1) 비트맵 (Bitmap)

각 블록 사용 여부 0 /1 표시 (1 = 사용 중, 0 = 빈 공간)

- **장점**
  빠른 탐색: 연속된 0을 찾아 새 파일 블록 할당 가능
  단편화 관리 용이
- **단점**
  대용량 디스크 → 비트맵 크기 커짐

### (2) 자유 리스트 (Free List)

빈 블록 주소를 연결 리스트로 관리

새 파일 블록 할당 → 리스트에서 제거
파일 삭제 → 리스트에 다시 추가

- **장점**
  구현 단순
  블록 크기나 위치와 관계없이 유연
- **단점**
  리스트 순차 검색 시 시간이 걸림 → 대용량 디스크에서는 느릴 수 있음

## 2-3. 디스크 단편화(Fragmentation)

### 단편화

: 디스크 공간이나 메모리가 효율적으로 연속해서 사용되지 못하고 흩어져 있는 상태

- 파일 저장/삭제/확장 관정에서 발생
- 단편화가 심하면 디스크 공간 낭비 + I/O 성능 저하 발생

⇒ 단편화는 **공간 효율과 성능에 직접적인 영향** → 파일 시스템 설계 시 필수 고려 요소

### 단편화의 유형

1. **외부 단편화(External Fragmentation)**: 빈 공간이 흩어져 있어 연속 블록 할당 어려움 (연속 할당 문제)

```jsx
사용 중: █ █   █   █ █ █   █
빈 공간:   █ █     █     █
// 빈 공간은 충분하지만, 연속된 블록 부족 -> 큰 파일 저장 불가
```

1. **내부 단편화(Internal Fragmentation)**: 블록 크기보다 작은 파일 → 남은 공간 낭비

- 할당 블록보다 파일 크기 가 작아서 남는 공간
  블록 크기: 4KB
  파일 크기: 3KB

> 연결 할당, 색인 할당은 외부 단편화 문제를 완화
