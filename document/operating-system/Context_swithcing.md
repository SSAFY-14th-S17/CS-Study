# 컨텍스트 스위칭(Context Switching)

> “같은 CPU를 여러 실행 흐름이 번갈아 쓰기 위해, 지금 상태를 **저장하고** 다른 상태를 **복원**하는 운영체제의 핵심 메커니즘”

---

## 1) Before reading

- **컨텍스트 스위칭**은 현재 실행 중인 프로세스/스레드의 **실행 문맥(context)** 을 저장하고, 다음에 실행할 실행 흐름의 문맥을 **복원**해 CPU를 넘겨주는 절차다.
- 문맥에는 **레지스터 집합(PC, SP, 일반 레지스터)**, **프로세스 상태**, **메모리 매핑(페이지 테이블/ASID)**, **커널 스택 포인터**, **스케줄러 메타데이터** 등이 포함된다.
- 장점: **응답성 향상**, **시분할 공유**, **공정성/우선순위 보장**.
- 비용: **저장/복원 오버헤드**, **캐시/TLB 미스 증가**, **스케줄러 결정 비용** → **지나치면 성능 저하(스레싱)**.
- 최소화 전략: **적절한 타임슬라이스**, **CPU 친화성(affinity)**, **우선순위 상속**, **NUMA-aware 스케줄링**, **동기화 설계 개선**.

---

## 2) 컨텍스트(Context)란?

**컨텍스트**는 실행을 “다시 이어서” 하기 위해 반드시 필요한 **프로세서·메모리·커널 측의 상태 묶음**이다.

- **CPU 레지스터 세트**: `PC(Program Counter)`, `SP(Stack Pointer)`, **일반/부동소수점 레지스터**, **상태 플래그**
- **프로세스/스레드 제어 정보**: 상태(RUNNABLE, BLOCKED, …), 우선순위, 타임슬라이스 잔량
- **메모리 문맥**: 주소 공간 식별자(ASID) 또는 CR3(페이지 테이블 루트), 영역별 접근 권한
- **커널 문맥**: 커널 스택 포인터, 시스템 콜/인터럽트 중간 상태
- **회계 정보**: 누적 CPU 시간, 스케줄러가 쓰는 통계(태스크 가중치, vruntime 등)

---

## 3) 언제 컨텍스트 스위칭이 발생하나?

- **타이머 인터럽트(선점)**: 타임슬라이스가 끝나면 OS가 강제로 선점
- **블록킹 이벤트**: I/O 대기, 락 대기, 페이지 폴트 처리 등으로 **READY → BLOCKED** 전이
- **우선순위 변화**: 더 높은 우선순위 태스크가 도착
- **시스템 콜**: `yield()`, `sched_yield` 등 자발적 CPU 반납
- **코어 간 이동**: 부하 균형(load balancing), CPU 핀 설정 변경 등

---

## 4) Process of Context Switiching

```
[현재 태스크 A 실행 중]
   └─(타이머 인터럽트 또는 블록)─► 1) 트랩 진입(커널 모드)
                                     2) A의 문맥 저장(커널 스택/PCB)
                                     3) 스케줄러 호출 & 다음 태스크 B 선택
                                     4) B의 문맥 복원(PCB→레지스터/메모리)
                                     5) 리턴-from-트랩로 유저/커널 모드 복귀
[태스크 B 실행 시작]
```

---

## 5) 상태 전이와 문맥 저장/복원

### 5.1 프로세스 상태 전이(개념도)

```
   +---------+       (준비 완료)          +---------+
   |  NEW    |  --------------------->  |  READY  |
   +---------+                          +----+----+
                                           |
                                           | (스케줄러 선택)
                                           v
                                       +---+-----+
                                       | RUNNING |
                                       +---+-----+
                                           |
             (I/O 요청/락대기)                |  (타임슬라이스 만료)
                +--------------------------+--------------------+
                |                                              |
                v                                              v
           +----+-----+                                  +----+----+
           | BLOCKED  |                                  |  READY  |
           +----+-----+                                  +----+----+
                |
                | (이벤트 완료)
                v
           +----+-----+
           |  READY   |
           +----------+
```

### 5.2 Context Save / Restore

```
저장(Save)                                  복원(Restore)
-----------                                  --------------
PC, SP, GP 레지스터  ─┐                 ┌─  PC, SP, GP 레지스터
FPU/SIMD 레지스터  ───┤  ───────────►   │   FPU/SIMD 레지스터
프로세스 상태, 우선순위   ┤   PCB/TCB       │  프로세스 상태/통계 반영
커널 스택 포인터       ─┘   (커널 영역)     └─  커널 스택 포인터
메모리 문맥(ASID/CR3)  (필요 시 저장)         메모리 문맥(ASID/CR3) 로드
```

---

## 6) 스레드 vs 프로세스 컨텍스트 스위칭

- **스레드 간 스위칭(동일 프로세스 내)**

  - **주소 공간을 공유**: 페이지 테이블/ASID 교체가 필요 없을 수 있음
  - 비용 상대적으로 **작음**(레지스터/스택 전환 중심)

- **프로세스 간 스위칭(상호 다른 주소 공간)**

  - **CR3/ASID 전환** → **TLB flush**(또는 ASID 기반 partial reuse) 확률 ↑
  - **캐시 로컬리티 손실** 가능성 ↑ → 비용 **상대적으로 큼**

> 현대 CPU는 **ASID(주소 공간 ID)** 로 서로 다른 주소 공간의 TLB 엔트리를 구분해 **전체 flush를 줄이는** 최적화를 사용하기도 한다.

---

## 7) 실제 오버헤드의 구성

1. **저장/복원 비용**: 레지스터, FPU/SIMD 상태, 커널 스택 포인터 등
2. **스케줄러 의사결정 비용**: 러너블 큐 탐색, 우선순위/가중치 계산
3. **메모리 지역성 손실**:

   - **TLB 미스**(페이지 테이블 재참조)
   - **L1/L2/L3 캐시 미스**(다른 태스크 워킹셋으로 오염)

4. **코어 간 마이그레이션 비용**:

   - 레지스터는 복원되지만, **다른 코어 캐시**엔 데이터가 없음
   - NUMA 환경에서는 **원격 메모리 접근 지연**도 증가

> 경험칙: “**스위칭 자체의 나노·마이크로초급 비용** + **메모리 지역성 붕괴로 인한 밀리초급 지연**”이 합쳐져 체감 성능에 영향을 준다.

---

## 8) 선점형 vs 비선점형과의 관계

- **선점형(Preemptive)**: 타이머/우선순위로 **강제 회수** → **인터랙티브 응답성** 우수, 스위칭 빈도 ↑
- **비선점형(Non-preemptive)**: 태스크가 **자발적 반납** → 스위칭 빈도 ↓, 긴 작업이 앞서면 **대기 지연 증가**

현대 범용 OS는 대체로 **선점형 커널·스케줄링**을 채택하고, **타임슬라이스**와 **우선순위 정책**으로 균형을 맞춘다.

---

## 9) “좋은” 컨텍스트 스위칭의 조건

- **필요할 때만**: I/O 대기·우선순위 역전 해소·응답성 확보 등 **정당한 이유**
- **적절한 빈도**: 너무 잦으면 오버헤드↑, 너무 드물면 응답성↓
- **지역성 보존**: CPU 친화성(동일 코어 재사용), 캐시/NUMA 의식적 배치
- **공정성과 QoS**: 우선순위 정책, 실시간 태스크에 대한 **지연 한계** 보장

---

## 10) 최소화·최적화 전략

- **타임슬라이스 조정**: 워크로드 특성에 맞게 길이 조절
- **CPU 친화성(Affinity)**: 같은 태스크를 **같은 코어**에서 계속 실행
- **우선순위 상속/에이징**: 락 경합·기아(starvation)로 인한 불필요 스위칭 감소
- **락 경합 완화**: 락 분해, RCU, lock-free 자료구조, 배치(batch) I/O
- **NUMA-aware 스케줄링**: 메모리·코어 토폴로지 고려
- **스레드 모델 설계**: 과도한 스레드/컨텍스트 전환 유발 구조 지양(예: 스레드 풀 튜닝)

---

## 11) Don't get it wrong.

- **“컨텍스트 스위칭 = 나쁨”** → **오해**

  - 적절한 스위칭은 **응답성**과 **공정성**을 높인다. 문제는 **과도한 빈도**와 **지역성 손실**.

- **“스레드는 항상 싸다”** → **부분적**

  - 프로세스보다 싸기 쉽지만, **락 경합/빈번한 잠금**으로 스위칭이 폭증하면 오히려 느려진다.

- **“실시간 시스템은 스위칭이 없다”** → **오해**

  - 오히려 **예측 가능한** 스위칭을 통해 **지연 상한**을 보장한다.

---

## 12) 컨텍스트 스위칭과 인터럽트/시스템 콜

- **인터럽트**: 하드웨어 신호로 커널에 **비동기 트랩** → 커널이 현재 문맥을 **임시 저장**하고 핸들러 수행
- **시스템 콜**: 유저 → 커널 모드 전환(트랩)이며, **항상 스위칭은 아님**(동일 태스크 내 모드 전환일 뿐)
- **실제 스케줄링 전환**은 트랩 처리 후 **스케줄러가 다른 태스크를 고르면** 발생

---

## 13) 타임슬라이스 기반 선점

```
시간 ─────────────────────────────────────────▶
코어0:  |  T1  |  T2  |  T3  |  T1  |  T2  |  T3  | ...
          ^      ^      ^      ^      ^      ^
          |      |      |      |      |      |
     (스위치) (스위치) (스위치) (스위치) (스위치) (스위치)
```

- 각 구간이 **타임슬라이스**. 슬라이스가 끝나면 **타이머 인터럽트**로 스케줄러가 개입, 다음 태스크로 **컨텍스트 스위칭**.

---

# 용어 사전

- **PCB/TCB**: 프로세스/스레드 제어 블록. 컨텍스트/스케줄링 메타데이터 저장
- **PC/SP**: 다음 명령 주소/현재 스택 프레임의 꼭대기 주소
- **ASID/CR3**: 주소 공간 식별자/페이지 테이블 루트 레지스터(x86)
- **TLB**: 가상→물리 주소 변환 캐시. 스위칭 시 미스 증가 가능
- **Affinity**: 태스크를 특정 CPU에 묶어 캐시 지역성 유지
- **Involuntary switch**: 선점/인터럽트 등 **강제 전환**
- **Voluntary switch**: `yield`, I/O 대기 등 **자발 전환**

---

## 마무리

컨텍스트 스위칭은 **멀티태스킹의 존재 이유**를 가능하게 하는 핵심 장치다. 중요한 것은 “얼마나 자주 하느냐”가 아니라, **“언제, 왜 하느냐”** 다. 스케줄러 정책과 시스템/애플리케이션 설계가 균형을 이루어야, 응답성과 처리량을 모두 지킬 수 있다.
